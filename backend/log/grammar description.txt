我的科研是将messy Table转换为 tidy Table.
Here is an example of messy tabular data:
[["Rank", "Name", "Age"],
 [1, "Bob", 16],
 ["", "Score", 92],
 [2, "Sam", 15], 
 ["", "Score", 89]]

The desired relational table should look like this:
[["Rank", "Name", "Age", "Score"],
 [1, "Bob", 16, 92],
 [2, "Sam", 15, 89]]

 但是现有data transformation工具或者编程库(如R语言中的tidyr，dplyr等，Python中的pandas等)都难以处理这种行列语义不一致的messy表格（如上述例子messy Table中的Age列既包含学生年龄信息，还包括学生分数信息，列的语义不一致。To address this issue, data practitioners currently resort to manually editing tables in tools like Excel or writing custom scripts in programming languages to transform non-standard tabular data into a standard format. However, manual editing is a tedious and labor-intensive process, while script development requires users to possess programming skills. Therefore, we propose an interactive transformation technique to support the transformation of messy tabular data into a desired relational table.
 为此，我先提出了一个声明式的转换语法，如下所述：

// The Declarative Grammar v0.3

interface AreaInfo {
    parent: AreaInfo | null, // 该区域的父区域
    areaLayer: number,       // 该区域在root区域下的层级
    templateIndex: number,   // 该区域属于父区域定义下的第几个模板
    xIndex: number,          // 该区域在父区域x轴方向上是第几个符合该模板的区域
    yIndex: number,          // 该区域在父区域y轴方向上是第几个符合该模板的区域
    xOffset: number,         // 该区域在父区域x轴方向上的偏移量
    yOffset: number,         // 该区域在父区域y轴方向上的偏移量
    x: number,               // 该区域在整个表格x轴方向上的坐标
    y: number,               // 该区域在整个表格y轴方向上的坐标
    width: number,           // 该区域的宽度
    height: number,          // 该区域的高度
    areaCells: AreaCell[],   // 该区域的所有单元格
    children: AreaInfo[]     // 该区域的子区域
}

interface AreaCell {
    xOffset: number,   // 该单元格在所在区域x轴方向上的偏移量
    yOffset: number,   // 该单元格在所在区域y轴方向上的偏移量
    value: cellValueType      // 该单元格的值
}

interface CellMapCol extends AreaCell {
    targetCol: string | null
}

type cellValueType = string | number
export enum ValueType {
    String,
    Number,
    None
}
type offsetFn = (currentAreaInfo: AreaInfo, rootAreaInfo: AreaInfo) => number
type checkValueFn = (value: cellValueType) => boolean
type mapColsFn = (currentAreaCells: AreaCell[]) => (string | null)[]
type mapColbyContextFn = (contextValue: cellValueType) => string | null
type contextPosiFn = (currentAreaInfo: AreaInfo, rootAreaInfo: AreaInfo) => CellSelection[]
type areaLayerFn = (currentAreaInfo: AreaInfo) => number

interface CellSelection {
    referenceAreaLayer?: 'current' | 'parent' | 'root' | areaLayerFn,  // 选定区域时参考区域的层级，默认为current
    referenceAreaPosi?: 'topLeft' | 'bottomLeft' | 'topRight' | 'bottomRight',  // 选定区域时参考区域的位置，默认为topLeft
    xOffset?: number | offsetFn,  // 选定区域时相对参考区域x轴方向上的偏移量，默认为0
    yOffset?: number | offsetFn   // 选定区域时相对参考区域y轴方向上的偏移量，默认为0
}

interface CellConstraint extends CellSelection {
    // cellValueType表示该单元格的值必须为某指定值；'string' | 'number'表示该单元格的值必须为字符串或数字；checkValueFn表示该单元格的值必须满足的自定义条件
    valueCstr: cellValueType | ValueType | checkValueFn
}

/**
 * position: 表示指定位置的单元格作为该单元格的 context cell
 * targetCol: 表示如何根据context cell得到该单元格对应的target column。其中：'cellValue' 表示使用该context cell的值作为target column，如果该context cell的值为空，则target column为null，此单元格不会被转换到output table中；mapColbyContextFn表示按照自定义规则根据context value匹配到指定target column。如果返回null，此单元格不会被映射到output table中。
 */
interface ContextTransform {
    // 
    position: 'top' | 'bottom' | 'left' | 'right' | contextPosiFn,
    targetCol: 'cellValue' | mapColbyContextFn
}

export interface TableTidierTemplate {
    startCell: CellSelection,
    size?: {
        width?: number | 'toParentX' | undefined,  // 选择区域的宽度，'toParentX' 表示从startCell到父区域的x轴终点的距离， undefined 表示不限制宽度；默认为1
        height?: number | 'toParentY' | undefined  // 选择区域的高度，'toParentY' 表示从startCell到父区域的y轴终点的距离， undefined 表示不限制高度；默认为1
    },
    constraints?: CellConstraint[],
    traverse?: {
        xDirection?: 'none' | 'after' | 'before' | 'whole';  // 遍历区域时x轴方向上的遍历顺序，after表示从startCell向后方向遍历，before表示从startCell向前方向遍历，whole表示遍历整个区域，默认为 none，表示不遍历
        yDirection?: 'none' | 'after' | 'before' | 'whole';  // 遍历区域时y轴方向上的遍历顺序，after表示从startCell向后方向遍历，before表示从startCell向前方向遍历，whole表示遍历整个区域，默认为 none，表示不遍历
    },
    transform?: {
        context?: ContextTransform,
        // string[] 表示该区域的所有单元格按照索引位置匹配到该数组对应的列内；'context' 表示该区域的所有单元格按照context cell返回值匹配到对应的列内;mapColsFn表示该区域的所有单元格按照自定义规则匹配到该函数返回的列内
        targetCols: (string | null)[] | 'context' | mapColsFn
    },
    children?: TableTidierTemplate[]
}

为了将上述列子中的 messy Table 转化为 desired relational table，基于上述语法，我们可以构造一个转换模板，如下所示：

const example: TableTidierTemplate = {
    startCell: {
        xOffset: 0,
        yOffset: 1
    },
    size: {
        width: 'toParentX',
        height: 2
    },
    constraints: [{
        xOffset: 0,
        yOffset: 0,
        valueCstr: ValueType.Number
    }],
    traverse: {
        yDirection: 'after'
    },
    children: [{
        startCell: {
            xOffset: 0,
            yOffset: 0
        },
        size: {
            width: 'toParentX',
        },
        transform: {
            targetCols: ["Rank", "Name", "Age"]
        }
    }, {
        startCell: {
            xOffset: 2,
            yOffset: 1
        },
        constraints: [{
            xOffset: -1,
            yOffset: 0,
            valueCstr: 'Score'
        }],
        transform: {
            targetCols: ["Score"]
        }
    }]
}

请你帮我规范我的语法：The Declarative Grammar v0.3，并为我的语法中每一个类别(包括函数类别)，每一个属性配上英文注释